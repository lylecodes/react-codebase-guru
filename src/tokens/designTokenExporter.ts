/**
 * Design token export system for various formats
 */

import { DesignPatterns } from '../patterns/patternExtractor';
import * as fs from 'fs-extra';
import * as path from 'path';

export interface DesignTokens {
  spacing: Record<string, string>;
  colors: {
    primary: Record<string, string>;
    secondary: Record<string, string>;
    neutral: Record<string, string>;
    semantic: Record<string, string>;
  };
  typography: {
    fontSizes: Record<string, string>;
    fontWeights: Record<string, string>;
    lineHeights: Record<string, string>;
    fontFamilies: Record<string, string>;
  };
  breakpoints: Record<string, string>;
  shadows: Record<string, string>;
  radii: Record<string, string>;
  transitions: Record<string, string>;
}

export interface ExportOptions {
  format: 'css' | 'scss' | 'js' | 'ts' | 'json' | 'tailwind' | 'styled-system';
  outputPath?: string;
  prefix?: string;
  includeComments?: boolean;
  groupByCategory?: boolean;
}

export class DesignTokenExporter {
  /**
   * Convert patterns to design tokens
   */
  convertToTokens(patterns: DesignPatterns): DesignTokens {
    return {
      spacing: this.generateSpacingTokens(patterns.spacing),
      colors: this.generateColorTokens(patterns.colors),
      typography: this.generateTypographyTokens(patterns.typography),
      breakpoints: this.getDefaultBreakpoints(),
      shadows: this.getDefaultShadows(),
      radii: this.getDefaultRadii(),
      transitions: this.getDefaultTransitions(),
    };
  }

  /**
   * Export tokens in specified format
   */
  async exportTokens(
    tokens: DesignTokens,
    options: ExportOptions
  ): Promise<string> {
    let output: string;

    switch (options.format) {
      case 'css':
        output = this.exportAsCSS(tokens, options);
        break;
      case 'scss':
        output = this.exportAsSCSS(tokens, options);
        break;
      case 'js':
        output = this.exportAsJS(tokens, options);
        break;
      case 'ts':
        output = this.exportAsTS(tokens, options);
        break;
      case 'json':
        output = this.exportAsJSON(tokens, options);
        break;
      case 'tailwind':
        output = this.exportAsTailwind(tokens, options);
        break;
      case 'styled-system':
        output = this.exportAsStyledSystem(tokens, options);
        break;
      default:
        throw new Error(`Unsupported format: ${options.format}`);
    }

    if (options.outputPath) {
      await fs.ensureDir(path.dirname(options.outputPath));
      await fs.writeFile(options.outputPath, output);
    }

    return output;
  }

  /**
   * Export as CSS custom properties
   */
  private exportAsCSS(tokens: DesignTokens, options: ExportOptions): string {
    const prefix = options.prefix || '';
    let css = '';

    if (options.includeComments) {
      css += '/* Design Tokens - Generated by React Codebase Guru */\n\n';
    }

    css += ':root {\n';

    // Spacing tokens
    if (options.includeComments) {
      css += '  /* Spacing */\n';
    }
    Object.entries(tokens.spacing).forEach(([key, value]) => {
      css += `  --${prefix}spacing-${key}: ${value};\n`;
    });

    // Color tokens
    if (options.includeComments) {
      css += '\n  /* Colors */\n';
    }
    Object.entries(tokens.colors.primary).forEach(([key, value]) => {
      css += `  --${prefix}color-primary-${key}: ${value};\n`;
    });
    Object.entries(tokens.colors.secondary).forEach(([key, value]) => {
      css += `  --${prefix}color-secondary-${key}: ${value};\n`;
    });
    Object.entries(tokens.colors.neutral).forEach(([key, value]) => {
      css += `  --${prefix}color-neutral-${key}: ${value};\n`;
    });
    Object.entries(tokens.colors.semantic).forEach(([key, value]) => {
      css += `  --${prefix}color-${key}: ${value};\n`;
    });

    // Typography tokens
    if (options.includeComments) {
      css += '\n  /* Typography */\n';
    }
    Object.entries(tokens.typography.fontSizes).forEach(([key, value]) => {
      css += `  --${prefix}font-size-${key}: ${value};\n`;
    });
    Object.entries(tokens.typography.fontWeights).forEach(([key, value]) => {
      css += `  --${prefix}font-weight-${key}: ${value};\n`;
    });

    // Other tokens
    if (options.includeComments) {
      css += '\n  /* Breakpoints */\n';
    }
    Object.entries(tokens.breakpoints).forEach(([key, value]) => {
      css += `  --${prefix}breakpoint-${key}: ${value};\n`;
    });

    if (options.includeComments) {
      css += '\n  /* Shadows */\n';
    }
    Object.entries(tokens.shadows).forEach(([key, value]) => {
      css += `  --${prefix}shadow-${key}: ${value};\n`;
    });

    css += '}\n';
    return css;
  }

  /**
   * Export as SCSS variables
   */
  private exportAsSCSS(tokens: DesignTokens, options: ExportOptions): string {
    const prefix = options.prefix || '';
    let scss = '';

    if (options.includeComments) {
      scss += '// Design Tokens - Generated by React Codebase Guru\n\n';
    }

    // Spacing
    if (options.includeComments) {
      scss += '// Spacing\n';
    }
    Object.entries(tokens.spacing).forEach(([key, value]) => {
      scss += `$${prefix}spacing-${key}: ${value};\n`;
    });

    // Colors
    if (options.includeComments) {
      scss += '\n// Colors\n';
    }
    Object.entries(tokens.colors.primary).forEach(([key, value]) => {
      scss += `$${prefix}color-primary-${key}: ${value};\n`;
    });
    Object.entries(tokens.colors.secondary).forEach(([key, value]) => {
      scss += `$${prefix}color-secondary-${key}: ${value};\n`;
    });

    // Typography
    if (options.includeComments) {
      scss += '\n// Typography\n';
    }
    Object.entries(tokens.typography.fontSizes).forEach(([key, value]) => {
      scss += `$${prefix}font-size-${key}: ${value};\n`;
    });

    return scss;
  }

  /**
   * Export as JavaScript object
   */
  private exportAsJS(tokens: DesignTokens, options: ExportOptions): string {
    let js = '';

    if (options.includeComments) {
      js += '// Design Tokens - Generated by React Codebase Guru\n\n';
    }

    js += 'export const tokens = ';
    js += JSON.stringify(tokens, null, 2);
    js += ';\n';

    return js;
  }

  /**
   * Export as TypeScript
   */
  private exportAsTS(tokens: DesignTokens, options: ExportOptions): string {
    let ts = '';

    if (options.includeComments) {
      ts += '// Design Tokens - Generated by React Codebase Guru\n\n';
    }

    // Add TypeScript interfaces
    ts += 'export interface DesignTokens {\n';
    ts += '  spacing: Record<string, string>;\n';
    ts += '  colors: {\n';
    ts += '    primary: Record<string, string>;\n';
    ts += '    secondary: Record<string, string>;\n';
    ts += '    neutral: Record<string, string>;\n';
    ts += '    semantic: Record<string, string>;\n';
    ts += '  };\n';
    ts += '  typography: {\n';
    ts += '    fontSizes: Record<string, string>;\n';
    ts += '    fontWeights: Record<string, string>;\n';
    ts += '    lineHeights: Record<string, string>;\n';
    ts += '    fontFamilies: Record<string, string>;\n';
    ts += '  };\n';
    ts += '  breakpoints: Record<string, string>;\n';
    ts += '  shadows: Record<string, string>;\n';
    ts += '  radii: Record<string, string>;\n';
    ts += '  transitions: Record<string, string>;\n';
    ts += '}\n\n';

    ts += 'export const tokens: DesignTokens = ';
    ts += JSON.stringify(tokens, null, 2);
    ts += ';\n';

    return ts;
  }

  /**
   * Export as JSON
   */
  private exportAsJSON(tokens: DesignTokens, _options: ExportOptions): string {
    return JSON.stringify(tokens, null, 2);
  }

  /**
   * Export as Tailwind CSS config
   */
  private exportAsTailwind(tokens: DesignTokens, options: ExportOptions): string {
    let config = '';

    if (options.includeComments) {
      config += '// Tailwind CSS Config - Generated by React Codebase Guru\n\n';
    }

    config += 'module.exports = {\n';
    config += '  theme: {\n';
    config += '    extend: {\n';

    // Spacing
    config += '      spacing: {\n';
    Object.entries(tokens.spacing).forEach(([key, value]) => {
      config += `        '${key}': '${value}',\n`;
    });
    config += '      },\n';

    // Colors
    config += '      colors: {\n';
    config += '        primary: {\n';
    Object.entries(tokens.colors.primary).forEach(([key, value]) => {
      config += `          '${key}': '${value}',\n`;
    });
    config += '        },\n';
    config += '        secondary: {\n';
    Object.entries(tokens.colors.secondary).forEach(([key, value]) => {
      config += `          '${key}': '${value}',\n`;
    });
    config += '        },\n';
    config += '      },\n';

    // Typography
    config += '      fontSize: {\n';
    Object.entries(tokens.typography.fontSizes).forEach(([key, value]) => {
      config += `        '${key}': '${value}',\n`;
    });
    config += '      },\n';

    config += '    },\n';
    config += '  },\n';
    config += '};\n';

    return config;
  }

  /**
   * Export as Styled System theme
   */
  private exportAsStyledSystem(tokens: DesignTokens, _options: ExportOptions): string {
    let theme = '';

    if (_options.includeComments) {
      theme += '// Styled System Theme - Generated by React Codebase Guru\n\n';
    }

    theme += 'export const theme = {\n';

    // Space
    theme += '  space: [\n';
    Object.values(tokens.spacing).forEach(value => {
      theme += `    '${value}',\n`;
    });
    theme += '  ],\n';

    // Colors
    theme += '  colors: {\n';
    Object.entries(tokens.colors.primary).forEach(([key, value]) => {
      theme += `    primary${key}: '${value}',\n`;
    });
    theme += '  },\n';

    // Font sizes
    theme += '  fontSizes: [\n';
    Object.values(tokens.typography.fontSizes).forEach(value => {
      theme += `    '${value}',\n`;
    });
    theme += '  ],\n';

    theme += '};\n';

    return theme;
  }

  // Token generation methods

  private generateSpacingTokens(spacing: any): Record<string, string> {
    const tokens: Record<string, string> = {};
    
    if (spacing.values && spacing.values.length > 0) {
      spacing.values.forEach((value: number, index: number) => {
        const multiple = spacing.unit > 0 ? value / spacing.unit : index + 1;
        tokens[multiple.toString()] = `${value}px`;
      });
    }

    return tokens;
  }

  private generateColorTokens(colors: any): DesignTokens['colors'] {
    return {
      primary: this.arrayToTokens(colors.primary || []),
      secondary: this.arrayToTokens(colors.secondary || []),
      neutral: this.arrayToTokens(colors.neutrals || []),
      semantic: {
        ...this.semanticColorsToTokens(colors.semantic || {}),
      },
    };
  }

  private generateTypographyTokens(typography: any): DesignTokens['typography'] {
    return {
      fontSizes: this.arrayToTokens(typography.fontSizes || [], 'xs'),
      fontWeights: this.fontWeightsToTokens(typography.fontWeights || []),
      lineHeights: {
        tight: '1.25',
        normal: '1.5',
        relaxed: '1.75',
      },
      fontFamilies: {
        sans: 'system-ui, sans-serif',
        serif: 'Georgia, serif',
        mono: 'Monaco, monospace',
      },
    };
  }

  private arrayToTokens(array: string[], _prefix?: string): Record<string, string> {
    const tokens: Record<string, string> = {};
    const sizeNames = ['xs', 'sm', 'base', 'lg', 'xl', '2xl', '3xl', '4xl', '5xl', '6xl'];
    
    array.forEach((value, index) => {
      const key = _prefix ? sizeNames[index] || `${_prefix}-${index}` : (index + 1).toString();
      tokens[key] = value;
    });

    return tokens;
  }

  private semanticColorsToTokens(semantic: any): Record<string, string> {
    const tokens: Record<string, string> = {};
    
    if (semantic.error) tokens.error = semantic.error[0];
    if (semantic.warning) tokens.warning = semantic.warning[0];
    if (semantic.success) tokens.success = semantic.success[0];
    if (semantic.info) tokens.info = semantic.info[0];

    return tokens;
  }

  private fontWeightsToTokens(weights: string[]): Record<string, string> {
    const tokens: Record<string, string> = {};
    const weightNames: Record<string, string> = {
      '100': 'thin',
      '200': 'extralight',
      '300': 'light',
      '400': 'normal',
      '500': 'medium',
      '600': 'semibold',
      '700': 'bold',
      '800': 'extrabold',
      '900': 'black',
    };

    weights.forEach(weight => {
      const name = weightNames[weight] || weight;
      tokens[name] = weight;
    });

    return tokens;
  }

  private getDefaultBreakpoints(): Record<string, string> {
    return {
      sm: '640px',
      md: '768px',
      lg: '1024px',
      xl: '1280px',
      '2xl': '1536px',
    };
  }

  private getDefaultShadows(): Record<string, string> {
    return {
      sm: '0 1px 2px 0 rgb(0 0 0 / 0.05)',
      md: '0 4px 6px -1px rgb(0 0 0 / 0.1)',
      lg: '0 10px 15px -3px rgb(0 0 0 / 0.1)',
      xl: '0 20px 25px -5px rgb(0 0 0 / 0.1)',
    };
  }

  private getDefaultRadii(): Record<string, string> {
    return {
      sm: '0.125rem',
      md: '0.375rem',
      lg: '0.5rem',
      xl: '0.75rem',
      '2xl': '1rem',
      full: '9999px',
    };
  }

  private getDefaultTransitions(): Record<string, string> {
    return {
      fast: '150ms ease-in-out',
      normal: '300ms ease-in-out',
      slow: '500ms ease-in-out',
    };
  }
}